% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi.R
\name{multi}
\alias{multi}
\alias{multi_add}
\alias{multi_new}
\alias{multi_run}
\title{Async multi download}
\usage{
multi_new(connections = 6, multiplex = FALSE)

multi_add(multi, handle, complete = identity, error = identity)

multi_run(multi, timeout = 0, verbose = FALSE)
}
\arguments{
\item{connections}{value for \code{CURLMOPT_MAX_TOTAL_CONNECTIONS}}

\item{multiplex}{uses HTTP/2 multiplexing when supported}

\item{multi}{a new handle pool}

\item{handle}{a prepared handle}

\item{complete}{callback on complete}

\item{error}{callback on error}

\item{timeout}{max seconds the pool is allowed to run. Use \code{0} to run pool until
all requests have completed.}

\item{verbose}{prints requests status messages to terminal}
}
\description{
Performs multiple concurrent requests, possibly using HTTP/2 multiplexing.
Advanced use only!
}
\details{
Schedule a series of requests to be executed simultaneously. Results are
available via callback functions, or at the end when all requests have
completed.

A single handle cannot be used for multiple simultaneous requests. However
it is possible (and often sensible) to re-use a handle within the callback
of a request from that same handle. It is up to the user to make sure the
same handle is not used in concurrent requests.

It is possible to add new requests to a pool while it is running. This can
be useful in situations where a given response requires subsequent requests
to retrieve additional information.
}
\examples{
pool <- multi_new()
h1 <- new_handle(url = "https://httpbin.org/get")
h2 <- new_handle(url = "https://httpbin.org/post", postfields = "bla bla")
multi_add(pool, h1, function(res){print(res)})
multi_add(pool, h2, function(res){print(res)})
multi_run(pool)
}

